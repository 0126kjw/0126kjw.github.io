---
layout: post
title: "[CS] 백엔드 기술 면접 예상 질문 Part2"
categories: CS
tags: CS Node.js
---

![2FT5JRJ07Z1V468MEQU9](https://user-images.githubusercontent.com/108377235/225361302-801bd6b9-881d-4fc1-98e7-051a12ac2566.jpg)

<br/>

## Intro

이번에 Node.js 개발자 기술 면접을 보고 왔는데, 면접관님에게 좋은 이야기를 많이 듣고 칭찬도 받아 굉장히 기분이 좋은 상태입니다.

하지만, 다음 면접을 준비하기 위해서는 들뜨지 않고 차분하게 학습을 하는 것이 중요하다고 생각합니다.

만약, 이 글을 읽고 계신 취준생분들이 계시다면 이 글을 통해 좋은 기운, 좋은 기분 얻어가실 수 있었으면 좋겠습니다.

그럼 이제 이전 포스팅에 이어서 백엔드 기술 면접 예상 질문을 정리해보겠습니다.

이전 포스팅에서는 주제별로 질문을 정리해보았지만, 내용이 많아.. 따로 나누지 않고 질문 및 답변을 작성해보겠습니다.

많은 내용의 출처를 모두 작성하지 못하는 점 이해해주시면 감사드리고, 만약 잘못된 내용이 있다면 댓글로 알려주시면 감사하겠습니다.

<br/>

### Question

#### RESTful API는 무엇이고 장단점은 무엇인가요?

RESTful API는 Representational State Transfer의 약자로, 웹 서비스를 구현하는 방법 중 하나입니다. RESTful API는 HTTP 요청을 통해 서버와 클라이언트 간에 리소스를 주고받습니다. 리소스는 웹 상의 데이터나 기능을 의미하며, 일반적으로 JSON이나 XML 형식으로 표현됩니다.

RESTful API에는 다음과 같은 특징이 있습니다:

- **확장성**: REST API를 구현하는 시스템은 클라이언트와 서버가 독립적으로 작동하므로 쉽게 크기 조정할 수 있습니다.
- **무상태성**: 서버는 클라이언트의 이전 요청 정보를 저장하지 않으므로 서버 부하를 줄일 수 있습니다.
- **일관성**: REST API는 HTTP 메서드(GET, POST, PUT, DELETE 등)와 URL 규칙을 따르므로 통신 방식이 일관되고 이해하기 쉽습니다.

RESTful API의 장점은 다음과 같습니다:

- **HTTP 프로토콜을 그대로 활용**: RESTful API는 HTTP 메서드와 URL 규칙을 따르므로 별도의 인프라를 구축할 필요가 없습니다. 또한 HTTP 프로토콜의 표준을 최대한 활용하여 캐싱, 보안, 압축 등의 기능을 이용할 수 있습니다.
- **다양한 플랫폼과 언어에 호환**: RESTful API는 JSON이나 XML 같은 범용적인 데이터 형식을 사용하므로 다양한 플랫폼과 언어에서 손쉽게 접근할 수 있습니다. 웹 뿐만 아니라 모바일이나 IoT 등에서도 적용할 수 있습니다.
- **유연하고 확장성이 높음**: RESTful API는 리소스와 표현 방식을 분리하므로 서버와 클라이언트가 독립적으로 변경되거나 발전할 수 있습니다. 또한 리소스를 모듈화하고 계층화하여 유연하게 관리할 수 있습니다.

RESTful API의 단점은 다음과 같습니다:

- **HTTP 메서드의 제한**: RESTful API는 HTTP 메서드를 사용하여 리소스를 표현하는데, 이 때문에 메서드 형태가 제한적이고 오해의 소지가 있을 수 있습니다. 예를 들어, PUT 메서드는 리소스 전체를 업데이트하는데 사용되지만, 일부분만 수정하는 경우에도 PUT 메서드를 사용해야 하는 문제가 있습니다.
- **공식화된 표준이 없음**: RESTful API는 아키텍처 스타일일 뿐 공식화된 표준이 존재하지 않기 때문에 개발자마다 설계 방식이 다를 수 있습니다. 이로 인해 관리가 어렵고 개발 시간과 비용이 증가할 수 있습니다.
- **데이터 전송량이 많아질 수 있음**: RESTful API는 리소스 상태에 대한 정보를 매번 전달하기 때문에 데이터 전송량이 많아질 수 있습니다. 또한 하나의 요청으로 여러 개의 리소스를 처리하기 어려울 수 있으므로 네트워크 부하가 증가할 수 있습니다.

<br/>

#### 서버 사이드 렌더링과 클라이언트 사이드 렌더링의 차이점과 장단점에 대해 설명하세요.

서버 사이드 렌더링과 클라이언트 사이드 렌더링은 웹 페이지를 구성하는 방식의 차이입니다. 서버 사이드 렌더링은 서버에서 HTML 파일을 만들어 브라우저로 전송하는 방식입니다. 클라이언트 사이드 렌더링은 서버에서 HTML 파일을 처리하지 않고, 브라우저의 자바스크립트를 통해 상호작용하는 방식입니다.

서버 사이드 렌더링과 클라이언트 사이드 렌더링의 장단점은 다음과 같습니다.

- 서버 사이드 렌더링: SEO에 유리하고, 초기 로딩 속도가 빠릅니다. 하지만 서버 부하가 크고, 페이지 전환 시 새로운 요청과 응답을 해야 합니다.
- 클라이언트 사이드 렌더링: 초기 로딩 이후에는 서버 요청 없이 동작하므로 속도가 빠르고, 사용자 경험이 좋습니다. 하지만 SEO에 취약하고, 초기 로딩 속도가 느립니다.

<br/>

#### MVC 패턴에 대해 설명하고 비슷한 디자인 패턴의 예시를 설명하세요.

MVC 패턴은 Model-View-Controller의 약자로, 애플리케이션을 세 가지 역할로 구분한 개발 방법론입니다.

- Model은 데이터와 비즈니스 로직을 담당하는 부분입니다. 데이터베이스나 파일 등의 외부 자원과의 연동을 처리하고, 사용자가 입력한 데이터나 출력할 데이터를 정의합니다.
- View는 사용자 인터페이스를 담당하는 부분입니다. 사용자에게 보여지는 화면을 구성하고, 사용자의 요청을 받아 Controller에 전달합니다.
- Controller는 Model과 View 사이의 상호작용을 관리하는 부분입니다. 사용자의 요청을 해석하고, 적절한 Model에게 작업을 지시하고, 결과를 View에게 전달합니다.

MVC 패턴의 장점은 다음과 같습니다.

- 각 구성요소가 독립적으로 개발되고 테스트될 수 있어 협업과 유지보수가 용이합니다.
- 재사용성과 확장성이 높아 애플리케이션의 생명주기를 연장할 수 있습니다.
- 중복 코드를 줄일 수 있어 개발 시간과 비용을 절약할 수 있습니다.

MVC 패턴의 단점은 다음과 같습니다.

- 설계가 복잡해 초보 개발자에게는 어려울 수 있습니다.
- 모델과 뷰 사이의 의존성이 높아 분리하기 어려울 수 있습니다.
- 컨트롤러가 과도하게 많은 역할을 수행해 복잡해질 수 있습니다.

MVC 패턴과 비슷한 디자인 패턴으로는 MVP (Model-View-Presenter) 패턴과 MVVM (Model-View-ViewModel) 패턴이 있습니다.

- MVP 패턴은 MVC 패턴에서 컨트롤러 대신 프레젠터를 사용하는 방식입니다. 프레젠터는 뷰와 모델 사이의 의존성을 제거하고, 뷰와 모델 간의 상호작용을 중재합니다. 프레젠터는 뷰와 1:1로 연결되며, 뷰에서 발생하는 이벤트를 처리하고 모델에서 받은 데이터를 가공하여 뷰에 전달합니다.
- MVVM 패턴은 MVC 패턴에서 컨트롤러 대신 뷰모델을 사용하는 방식입니다. 뷰모델은 뷰와 모델 사이에 위치하며, 데이터 바인딩(Data Binding) 기술을 통해 뷰와 모델 간의 동기화를 자동으로 처리합니다. 뷰모델은 뷰와 1:n으로 연결될 수 있으며, UI 로직을 담당하고 모델에서 받은 데이터를 변환하여 저장합니다.

<br/>

#### 객체 지향 프로그래밍과 함수형 프로그래밍의 차이점과 장단점에 대해 설명하세요.

oop와 fp는 프로그래밍 패러다임(디자인 패턴)의 한 종류입니다.

- oop: Object Oriented Programming의 약자로, 프로그램을 객체(object)라는 기본 단위로 나누고 이들의 상호작용으로 서술하는 방식입니다. 객체는 데이터와 메소드(method)를 묶어서 하나의 역할을 수행합니다. oop의 장점은 코드의 재사용성과 유지보수성을 높이고, 캡슐화(encapsulation), 상속(inheritance), 다형성(polymorphism) 등의 특징을 활용할 수 있다는 점입니다. oop의 단점은 객체 간의 의존성(dependency)이 높아져서 복잡도가 증가하고, 성능이 저하될 수 있다는 점입니다.
- fp: Functional Programming의 약자로, 프로그램을 순수한(pure) 함수(function)들의 조합으로 서술하는 방식입니다. 순수한 함수란 부작용(side effect)이 없고, 동일한 입력에 대해 항상 동일한 출력을 내는 함수를 말합니다. fp의 장점은 코드가 간결하고 가독성이 좋으며, 병렬 처리(parallel processing)와 테스트(testing), 디버깅(debugging)이 용이하다는 점입니다. fp의 단점은 추상화(abstraction) 수준이 높아져서 이해하기 어렵고, 성능이 저하될 수 있다는 점입니다.

<br/>

#### TDD(테스트 주도 개발)에 대해 설명하세요.

tdd는 Test Driven Development의 약자로 '테스트 주도 개발’이라고 합니다. 테스트 주도 개발은 테스트 케이스를 먼저 작성하고, 그에 맞는 코드를 구현하는 방식입니다. tdd의 장점은 코드의 품질과 신뢰성을 높이고, 리팩토링(refactoring)과 유지보수를 용이하게 한다는 점입니다. tdd의 단점은 테스트 케이스 작성에 시간과 비용이 들고, 테스트 커버리지(coverage)가 낮거나 테스트 케이스가 잘못 작성될 수 있다는 점입니다.

tdd의 단계는 다음과 같습니다.

1. 실패하는 테스트 케이스를 작성합니다. 요구사항을 반영하는 테스트 케이스를 먼저 작성하고, 실행해봅니다. 이때 테스트는 실패해야 합니다.
2. 테스트를 통과하는 코드를 작성합니다. 테스트 케이스를 만족시키기 위한 최소한의 코드를 작성하고, 다시 테스트를 실행합니다. 이때 테스트는 성공해야 합니다.
3. 코드를 개선합니다. 작성한 코드에 대해 리팩토링(refactoring)을 수행하여 중복을 제거하고 가독성을 높입니다.

tdd의 원칙은 다음과 같습니다.

- 테스트 케이스는 한 번에 하나씩만 작성합니다.
- 테스트 케이스는 명확하고 간결하게 작성합니다.
- 테스트 케이스는 모든 가능한 시나리오와 예외 상황을 커버해야 합니다.
- 테스트 케이스는 자동화되어야 합니다.
- 테스트를 통과하기 위한 최소한의 코드만 작성 및 개선합니다.

<br/>

#### CI/CD의 개념과 과정에 대해 설명하세요.

CI/CD는 애플리케이션의 통합 및 테스트 단계에서부터 제공 및 배포에 이르는 애플리케이션의 라이프사이클 전체에 걸쳐 지속적인 자동화와 지속적인 모니터링을 제공하는 것입니다. CI/CD의 핵심 개념은 다음과 같습니다.

- 지속적인 통합(Continuous Integration): 개발자들이 작성한 코드를 정기적으로 통합하고 자동으로 빌드와 테스트를 수행하여 코드의 품질과 안정성을 유지하는 것입니다.
- 지속적인 서비스 제공(Continuous Delivery): 통합된 코드를 자동으로 운영 환경과 유사한 환경에 배포하고 검증하여 언제든지 실제 운영 환경에 배포할 수 있는 상태를 유지하는 것입니다.
- 지속적인 배포(Continuous Deployment): 검증된 코드를 자동으로 실제 운영 환경에 배포하여 고객에게 빠르게 서비스를 제공하는 것입니다.

CI/CD의 과정은 다음과 같습니다.

- 개발자가 로컬에서 코드를 작성하고 버전 관리 시스템(Git 등)에 커밋합니다.
- CI 서버(Jenkins 등)가 버전 관리 시스템에서 새로운 커밋을 감지하고 코드를 가져와서 빌드와 테스트를 수행합니다.
- CI 서버가 빌드와 테스트 결과를 개발자에게 피드백합니다. 오류가 발생하면 수정합니다.
- CD 서버(Jenkins 등)가 CI 서버에서 전달받은 코드를 스테이징 환경(운영 환경과 유사한 환경)에 배포하고 추가적인 검증을 수행합니다. 오류가 발생하면 수정합니다.
- CD 서버가 스테이징 환경에서 검증된 코드를 운영 환경에 배포합니다.

CI/CD는 애플리케이션 개발과 운영의 속도와 안정성을 높여주는 방법입니다. CI/CD 도구나 서비스로는 Jenkins, Travis CI, AWS CodePipeline, GitLab CI/CD 등이 있습니다.

<br/>

#### 배포 자동화에 대해 설명하세요.

배포 자동화는 개발된 애플리케이션을 운영 환경에 배포하는 과정을 자동화하는 것입니다.

배포 자동화의 장점은 다음과 같습니다.

- 배포 시간과 비용을 절약할 수 있습니다. 수동으로 배포하는 경우에는 인력과 시간이 많이 소요되지만, 자동화를 통해 빠르고 정확하게 배포할 수 있습니다.
- 배포 오류와 장애를 줄일 수 있습니다. 수동으로 배포하는 경우에는 인간의 실수나 누락이 발생할 수 있지만, 자동화를 통해 일관된 방식으로 배포할 수 있습니다.
- 지속적인 통합/지속적인 제공(CI/CD)을 지원할 수 있습니다. 개발과 테스트에서 제공과 배포에 이르는 라이프사이클 전체를 지속적으로 자동화하고 모니터링하여 고객에게 빠르고 안정적인 애플리케이션을 제공할 수 있습니다.

배포 자동화의 단점은 다음과 같습니다.

- 초기 구축 비용이 들 수 있습니다. 배포 자동화를 위한 도구나 서비스를 선택하고 설치하고 설정하는 과정에 시간과 비용이 소요될 수 있습니다.
- 보안 문제가 발생할 수 있습니다. 배포 자동화를 위한 도구나 서비스가 해커의 공격 대상이 될 수 있으므로, 보안 강화와 관리가 필요합니다.

배포 자동화를 위해 사용하는 도구나 서비스는 다양합니다. 예를 들어, Jenkins, Travis CI, AWS CodeDeploy, Ansible 등이 있습니다.

<br/>

#### 쿠키와 세션의 차이점과 작동 원리에 대해 설명하세요.

쿠키와 세션은 웹에서 사용자의 상태 정보를 저장하는 방법입니다. 쿠키는 사용자의 컴퓨터에 작은 파일로 저장되고, 세션은 서버에 저장됩니다. 쿠키는 서버의 자원을 사용하지 않지만 보안이 약하고, 세션은 서버의 자원을 사용하지만 보안이 강합니다. 쿠키와 세션은 주로 로그인 상태 유지, 장바구니 기능, 방문 횟수 카운트 등에 사용됩니다.

쿠키와 세션의 작동 원리는 다음과 같습니다.

- 쿠키: 사용자가 웹 사이트에 접속하면 서버는 사용자의 정보를 담은 쿠키를 생성하고 응답 헤더에 넣어서 보냅니다. 사용자의 브라우저는 쿠키를 받아서 저장하고, 다시 서버에 요청할 때마다 쿠키를 요청 헤더에 넣어서 보냅니다. 이렇게 하면 서버는 사용자의 상태 정보를 알 수 있습니다.
- 세션: 사용자가 웹 사이트에 접속하면 서버는 사용자의 정보를 담은 세션 객체를 생성하고, 세션 ID를 발급합니다. 서버는 세션 ID를 쿠키로 만들어서 응답 헤더에 넣어서 보냅니다. 사용자의 브라우저는 세션 ID가 담긴 쿠키를 받아서 저장하고, 다시 서버에 요청할 때마다 쿠키를 요청 헤더에 넣어서 보냅니다. 이렇게 하면 서버는 세션 ID로 세션 객체를 찾아서 사용자의 상태 정보를 알 수 있습니다.

<br/>

#### 스택과 큐의 정의와 특징에 대해 설명해주세요.

스택은 책을 쌓는 것처럼 차곡차곡 쌓아 올린 형태의 자료구조입니다. 스택에서는 가장 위에 있는 데이터만 접근하고 삭제할 수 있습니다. 이를 **후입선출(Last In First Out, LIFO)** 방식이라고 합니다.

스택의 특징은 다음과 같습니다.

- 스택은 재귀 알고리즘을 사용하는 경우에 유용합니다.
- 스택은 웹 브라우저의 뒤로 가기 기능이나 실행 취소 기능 등에 활용될 수 있습니다.
- 스택은 단순하고 효율적인 자료구조입니다.

큐는 먼저 들어온 데이터가 먼저 나가는 **선입선출(First In First Out, FIFO)** 방식의 자료구조입니다. 큐에서는 한 쪽 끝에서만 데이터를 삽입하고 다른 쪽 끝에서만 데이터를 삭제할 수 있습니다.

큐의 특징은 다음과 같습니다.

- 큐는 운영체제의 작업 스케줄링이나 인쇄 대기열 등에 활용될 수 있습니다.
- 큐는 순서대로 처리해야 하는 작업들을 임시로 저장하는데 유용합니다.
- 큐는 배열이나 연결리스트로 구현할 수 있습니다.

<br/>

#### 대칭키와 공개키 암호화의 차이점에 대해 설명하세요.

대칭키와 공개키 암호화의 차이점은 다음과 같습니다.

- 대칭키 암호화는 암호화와 복호화에 사용하는 키가 **동일**한 방식입니다. 예를 들어, A와 B가 대칭키 암호화로 통신하려면 미리 같은 키를 공유해야 합니다. 대칭키 암호화는 속도가 빠르지만 키를 안전하게 교환하는 문제가 있습니다.
- 공개키 암호화는 암호화와 복호화에 사용하는 키가 **서로 다른** 방식입니다. 예를 들어, A가 B에게 메시지를 보내려면 B의 공개키로 메시지를 암호화하고, B는 자신의 개인키로 메시지를 복호화합니다. 공개키는 모두에게 공개되어 있고 개인키는 각자만 가지고 있습니다. 공개키 암호화는 키 교환 문제를 해결하지만 속도가 느립니다.

<br/>

#### 해시 함수와 암호화의 차이점에 대해 설명하세요.

해시 함수는 **단방향 암호화**이므로 복호화가 불가능하며, 데이터 보안에 중점을 두었습니다. 즉, 평문을 암호문으로 변환하면 결과 암호문(일명 해시)으로부터 절대로 복구할 수 없습니다.

암호화는 **양방향 암호화**이므로 복호화가 가능하며, 통신에서의 보안에 중점을 두었습니다. 즉, 평문을 암호문으로 변환한 후 다시 평문으로 변환할 수 있습니다.

---

이렇게 두 파트로 나눈 백엔드 기술 면접 예상 질문에 대해 작성해보았습니다.

두 포스팅의 내용은 백엔드 개발자가 알아야 할 가장 기초적인 지식에 해당한다고 생각하며, 더 많은 컴퓨터 공학 지식을 알아두어야 실무에서 도움이 될 것이라고 생각합니다.

또한, 기술 면접에서 자주 등장하는 질문들을 간추려 정리하였기 때문에 급하신 분들에게 도움은 되더라도 꼭 긴 시간의 학습을 통해 이론적인 준비를 갖춰두는 것을 추천합니다.

기회가 된다면 이후 면접에서 실제로 받은 질문에 대해 정리해 포스팅하도록 하겠습니다.

<br/>

위 내용 중 잘못된 부분이 있다면 댓글로 알려주시면 감사하겠습니다.
